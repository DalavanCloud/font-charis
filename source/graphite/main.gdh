/*
    Title:   Roman Font GDL description
    Authors: Martin Hosken, Bob Halllissy, Joan Wardell, Sharon Correll


	This file is part of Charis font family
	(http://scripts.sil.org/CharisSIL) and is
	Copyright (c) 2003-2010 SIL International (http://www.sil.org/),
	with Reserved Font Names "Charis" and "SIL".

	This Font Software is licensed under the SIL Open Font License,
	Version 1.1.

	You should have received a copy of the license along with this Font Software.
	If this is not the case, go to (http://scripts.sil.org/OFL) for all the
	details including a FAQ.


    Changes:
AKW 2013-Mar-05  Remove Deprecated PUA feature
SJC 2008-Oct     More changes for ditto
SJC 2008-Aug-26  Various changes for small-caps, deprecated PUA, etc.
SJC 2008-Apr-23  Changed Tat alternates back to H-stroke alternates
SJC 2008-Apr-15  Patch (kludge) to handle dotless i w/ alternate tail
AKW 2008-Apr-02  Restore hookabove glyphs to Vietnamese diacritic classes
SJC 2007-Oct-31  Added #ifs for Gentium Basic and Gentium Book Basic
SJC 2007-Jan-26  Cleaned up distinction between Open-O alternates and J-stroke-hook-alternate
SJC 2006-Dec-4   Various changes for new version to support Unicode 5.0:
	Changed VNStyle to vN; added Chinantec tones, Cyrillic cursive italics, open-o serif feature
SJC 2006 ??????  Added barred-j modifier to take smaller diacritics; added smallcaps code (turned off)
SJC 2006-Apr-6   Allow ogonek and literacy rules to both fire
SJC 2006-Mar-21  Handle literacy alternates + Vietnamese diacritics for NFC data
SJC 2006-Jan-23  Added Cyrillic shha alternate
SJC 2005-Oct-14  Added slant-italic ff, fi, fl ligatures
SJC 2005-Oct-13  Made ff, fi, fl true ligatures with components.
SJC 2005-Oct-12  Fixed problems with dotted modifier super/subscripts and partial fix for F17A (double diaeresis).
SJC 2005-Sep-1   Added slant-italic special forms, diaersis on superscripts, and bridging diacritics.
SJC 2005-May-16  Handle features modlowcolon, ltnglottalstop, and ltnjstroke.
SJC 2005-May-16  Turn off AutoPseudo.
SJC 2005-May-10  Added a few comments.
AKW 2005-May-09  Changed gF176 to g035C (PUA character accepted into Unicode).
JMW 2004-Sep-02  For now, I will take easy option on fixing Literacy Alts and Romanian,
    by backing up. Later I may re-write. Input to WP2 is now NFD, necessitating a change.
JMW 2004-Jul-21  Comments on Viet, add 4th Eng.
RMH 2004-Mar-17  Changed logic for ou alternates due to default is now closed top,
	and alternate is .OpenType  (issue RFS-5WXH4D);
	added omacron and Omacron to things that can composite with ogonek (related to issue RFS-5X5FKC);
	renamed cnDia to cDia -- it is a class of all diacritics, not the class of non-diacritics;
	added cHDia to cBDia, but I think the cBDia and cnBDia classes aren't used...?
RMH 2004-Feb-25  removed all smartcode that builds alternates (of composites) by decomposition
	(we now have real alternates available in the font);
	in the process, eliminated viet.gdh -- integrating it directly here.
RMH 2004-Feb-13  Made explicit associations to quiet new GrCompiler warnings.
RMH 2004-Feb-05  Rewrote rules that had been generated by normal_rules() function in makegdl.pl so
	that (1) only those glyphs that need composition (things with ogonek, cedilla, horn)
	are actually composed, and (2) now permits other diacritcs to intervene.
	Similarly added code to permit intevening diacs in rules for .vNStyle diac ligatures.
RMH 2004-Feb-04 Changes after B14: implemented logic for retrohookstyle ogonek alternates feature.
RMH 2004-Jan-19 Changes after B10: omehow p_hook feature wasn't ever implemented.
RMH 10-Oct-2003 Significant rework:
	added "else" clauses for most features (so this same code works if
	Feature table and cmap are changed so an "alternate" glyph is the default);
	added code to handle cedillas that need to be rendered as commaaccent;
	added DeBuG feature (only compiled in if symbol DEBUG is defined as non-zero).
RMH 01-Sep-2003 Reworked all features per PC's design.
RMH 15-Aug-2003  Added other Unicode 4.0 double-diacritics;
    fixed double diacritic positioning so not dependent on glyph's default location
	(requires double diacritics should NOT have attachment points).
RMH 17-Jul-2003  Removed all references to "P" and "_P" attachment points -- it no longer exists;
    replace refs to U+F177 with U+035E (Unicode 4.0).
RMH 10-Jul-2003  Added logic to decompose 1E2D and 1ECB in the context of upper diacritics.
MJPH 16-Nov-2002 Move overarch to down by -1200m from -700m.
*/

#include "stddef.gdh"

#define CHARISfont 1
#define DOULOSfont 2
#define GENTIUMBASICfont 3
#define GENTIUMBOOKBASICfont 4
#define GENTIUMfont 5
#define GENTIUMBOOKfont 6
#define ANDIKABASICfont 7
#define ANDIKAfont 8

/////#define GENBASICfamily (FONT == GENTIUMBASICfont || FONT == GENTIUMBOOKBASICfont)
#define BASIC (FONT == GENTIUMBASICfont || FONT == GENTIUMBOOKBASICfont || FONT == ANDIKABASICfont)
#define ANDIKAfamily (FONT == ANDIKAfont || FONT == ANDIKABASICfont)
#define GENTIUMfamily (FONT == GENTIUMBASICfont || FONT == GENTIUMBOOKBASICfont || FONT == GENTIUMfont || FONT == GENTIUMBOOKfont)

// Now turn on the font we want, so we get specific features. (This file is copied from
// something like doulos.gdh or charis.gdh by the build process.)
#include "fontSpecific.gdh"

#define DEBUG 0
// #define DEBUG 1  //jw 7/21/04 Use this to turn on DEBUG

#define SMALLCAPS 0

Bidi = 0;

// We handle double-encoded glyphs by hand, for the deprecated-PUA feature.
AutoPseudo = 0;

#define DIASTR3(x) [ x [ x x?]?]?
#define DIASTR4(x) [ x [ x [ x x?]?]?]?
#define DIASTR5(x) [ x [ x [ x [ x x?]?]?]?]?
#define attached	user1

// user1 - user4 are used in pitches.gdh
// user1 is used by both pitch and attachment stuff because there should not be any conflict.
// user2 is used by both pitch and low-profile stuff because there should not be any conflict.

#define needs_lp	user2

// #define pua		user5

#define LP_DIACONLY 0
#define LP_BASEONLY 1
#define LP_BASEDIAC 2

////#define KERNPASS 3

#if DEBUG
#define DeBuG gltncapd g_e gltncapb g_u gltncapg g_colon
#endif

//////////////////////////////////////////////////////////////////////////////////////
//
//	Glyphs
//

table(glyph);

// To make upstream whitespace be reordered at the end of a line; shouldn't be
// needed if compiler is working correctly.
//clsSpaces = (g_space, g2000, g2001, g2002, g2003, g2004, g2005
//				g2006, g2007, g2008, g2009, g200A, g200B)
//			{ dir = DIR_WHITESPACE };


// Additions to feature classes for small caps; these are not included
// automatically by make_gdl.

cBaselineHook += (gltnsmeng_BaselineHook_sc); // but these classes aren't really used
cUCStyle += (gltnsmeng_UCStyle_sc);
cKom += (gltnsmeng_Kom_sc);
cno_BaselineHook += (gltnsmeng_sc);
cno_UCStyle += (gltnsmeng_sc);
cno_Kom += (gltnsmeng_sc);

// This class is not useful since there are two different features that use "topBar":
//cTopBar += (g0253_topBar_sc);
//cno_TopBar += (g0253_sc);

cTopBarB = (gltnsmbhook_topbar, gltncapbhook_topbar, gltnsmbhook_TopBar_sc);
cno_TopBarB = (gltnsmbhook, gltncapbhook, gltnsmbhook_sc);

cTopBarD = (gltncapdhook_topbar, gltnsmdhook_TopBar_sc);
cno_TopBarD = (gltncapdhook, gltnsmdhook_sc);

cVertStrk += (gltnsmhstrk_VertStrk_sc);
cno_VertStrk += (gltnsmhstrk_sc);

//cCommaStyle += (g_scedilla_comma_style_sc, g0163_commaStyle_sc);
//cno_CommaStyle += (g_scedilla_sc, g0163_sc);

cTopSerif += (gltnsmopno_TopSerif_sc);
cno_TopSerif += (gltnsmopno_sc);

cLCStyleNhook = (gltncapnlfthook_lcstyle, gltnsmnlfthook_LCStyle_sc);
cno_LCStyleNhook = (gltncapnlfthook, gltnsmnlfthook_sc);

cLCStyleRtail = (gltncapsmrhooktail, gltnsmcapsmrhooktail); // what about lowercase r-tail SC?
cno_LCStyleRtail = (gltncaprhooktail, gltnsmrhooktail_sc);

cRtHookThook = (gltncapthook_rthook, gltnsmthook_RtHook_sc);
cno_RtHookThook = (gltncapthook, gltnsmthook_sc);

cRtHookYhook = (gltncapyhook_rthook, gltnsmyhook_RtHook_sc);
cno_RtHookYhook = (gltncapyhook, gltnsmyhook_sc);

cStraightLft += (gltnsmvhook_StraightLft_sc);
cStraightLftHighHook += (gltnsmvhook_StraightLftHighHook_sc);
cno_StraightLft += (gltnsmvhook_sc);
cno_StraightLftHighHook += (gltnsmvhook_sc);

cRevSigmaStyle += (gcysmabkhasdze_RevSigmaStyle_sc, gltnsmezh_RevSigmaStyle_sc);
cno_RevSigmaStyle += (gcysmabkhasdze_sc, gltnsmezh_sc);

cOpenTop += (gltnsmou_OpenTop_sc);
cno_OpenTop += (gltnsmou_sc);

cMongolStyle += (gcysme_MongolStyle_sc);
cno_MongolStyle += (gcysme_sc);

cLrg += (gltnsmsaltillo_Lrg_sc);
cno_Lrg += (gltnsmsaltillo_sc);

cRetroHook += (
		gltnsmaogonek_RetroHook_sc,	gltnsmaogonek_SngStory_RetroHook_sc,	gltnsmeogonek_RetroHook_sc,
		gltnsmiogonek_RetroHook_sc,	gltnsmuogonek_RetroHook_sc, 			gltnsmoogonek_RetroHook_sc,			gltnsmoogonekmacron_RetroHook_sc);
cno_RetroHook += (
		gltnsmaogonek_sc,					gltnsmaogonek_SngStory_sc,			gltnsmeogonek_sc,
		gltnsmiogonek_sc,					gltnsmuogonek_sc,					gltnsmoogonek_sc,					gltnsmoogonekmacron_sc);



cVN += (gltnsmacircumacute_VN_sc,	gltnsmacircumgrave_VN_sc,	gltnsmacircumtilde_VN_sc,	gltnsmacircumhookabv_VN_sc,
		gltnsmabreveacute_VN_sc,	gltnsmabrevegrave_VN_sc,	gltnsmabrevetilde_VN_sc,	gltnsmabrevehookabv_VN_sc,
		gltnsmacircumacute_SngStory_VN_sc,	gltnsmacircumgrave_SngStory_VN_sc,	gltnsmacircumtilde_SngStory_VN_sc,	gltnsmacircumhookabv_SngStory_VN_sc,
		gltnsmabreveacute_SngStory_VN_sc,	gltnsmabrevegrave_SngStory_VN_sc,	gltnsmabrevetilde_SngStory_VN_sc,	gltnsmabrevehookabv_SngStory_VN_sc,
		gltnsmecircumacute_VN_sc,	gltnsmecircumgrave_VN_sc,	gltnsmecircumtilde_VN_sc,	gltnsmecircumhookabv_VN_sc,	gltnsmocircumacute_VN_sc,	gltnsmocircumgrave_VN_sc,	gltnsmocircumtilde_VN_sc,	gltnsmocircumhookabv_VN_sc);

cno_VN += (gltnsmacircumacute_sc,	gltnsmacircumgrave_sc,		gltnsmacircumtilde_sc,		gltnsmacircumhookabv_sc,
		gltnsmabreveacute_sc,		gltnsmabrevegrave_sc,		gltnsmabrevetilde_sc,		gltnsmabrevehookabv_sc,
		gltnsmacircumacute_SngStory_sc,		gltnsmacircumgrave_SngStory_sc,		gltnsmacircumtilde_SngStory_sc,		gltnsmacircumhookabv_SngStory_sc,
		gltnsmabreveacute_SngStory_sc,		gltnsmabrevegrave_SngStory_sc,		gltnsmabrevetilde_SngStory_sc,		gltnsmabrevehookabv_SngStory_sc,
		gltnsmecircumacute_sc,		gltnsmecircumgrave_sc,		gltnsmecircumtilde_sc,		gltnsmecircumhookabv_sc,		gltnsmocircumacute_sc,		gltnsmocircumgrave_sc,		gltnsmocircumtilde_sc,		gltnsmocircumhookabv_sc);


// Why is there no g_lcaron_caron_sc??

// Give a better name:
c_sc = csc;


// Classes of double-diacritics above and below:
cUDblDia = (gcombdblbreve  gcombdblmacron  gcombdbltilde  gcombdblinvbreve  gf17a	gcombdblcircum);
cLDblDia = (gcombdblmacronblw  gcombdblrtarrwblw  gcombdblbreveblw);


// Various classes of diacritics; the classes generated by make_gdl are not helpful.
cBDia = (cLDia cODia cHDia);				// Below = Lower + Ogonek + Cedilla
cnBDiaX = (cUDia cRDia);					// Not Below
cnHDiaX = (cLDia cODia cRDia cUDia);		// Not Cedilla
cnLDiaX = (cHDia cODia cRDia cUDia);		// Not Lower
cnODiaX = (cHDia cLDia cRDia cUDia);		// Not Ogonek
cnRDiaX = (cHDia cLDia cODia cUDia);		// Not Horn (right)
cnUDiaX = (cHDia cLDia cODia cRDia );		// Not Upper
cDia =  (cHDia cLDia cODia cRDia cUDia);	// Any (but not double dias)

// ff, fi, fl ligatures

cfLigC2 = (gltnsmf  gltnsmi  gltnsml);
cfLig  = (gltnligsmfsmf  gltnligsmfsmi  gltnligsmfsml);
cffLigC3 = (gltnsmi  gltnsml);
cffLig = (gltnligsmfsmfsmi  gltnligsmfsmfsml);

cfLigC2_sItal  = (gltnsmf_sital, gltnsmi_sital, gltnsml_sital);
cfLig_sItal    = (gltnligsmfsmf_sital, gltnligsmfsmi_sital, gltnligsmfsml_sital);
cffLigC3_sItal = (gltnsmi_sital, gltnsml_sital);
cffLig_sItal   = (gltnligsmfsmfsmi_sital, gltnligsmfsmfsml_sital);

cfLig_all = (cfLig  cfLig_sItal)
	{ component {f1 = box(0, -descent, aw/2, ascent); f2 = box(aw/2, -descent, aw, ascent) }};
cffLig_all = (cffLig  cffLig_sItal)
	{ component { f1 = box(0, -descent, aw/3, ascent);
					f2 = box(aw/3, -descent, (2*aw)/3, ascent);
					f3 = box((2*aw)/3, -descent, aw, ascent) }}

cSpecialDotted = (gltnsmitildeblw  gltnsmidotblw);		// i with lower diacritics
cSpecialDottedDia = (gcombtildeblw  gcombdotblw);


// Special class defs for cedilla compositions that are rendered as commaaccent:
cCedillaBase = (gltncapg  gltnsmg  gltncapk  gltnsmk  gltncapl  gltnsml  gltncapn  gltnsmn  gltncapr  gltnsmr);
cCedillaComposite = (gltncapgcedilla g_gcommaaccent gltncapkcedilla g_kcommaaccent
		g__lcommaaccent	gltnsmlcedilla g__ncommaaccent gltnsmncedilla g__rcommaaccent
		gltnsmrcedilla);

// Add in other cedilla composites:
cCedillaBase += (gltncapc  gltnsmc  gltncaps  gltnsms  gltncapt  gltnsmt  gltncape  gltnsme  gltnsms_sc  gltnsmt_sc)
cCedillaComposite += (gltncapccedilla g_ccedilla gltncapscedilla g_scedilla
		gltncaptcedilla  gltnsmtcedilla  gltncapecedilla  gltnsmecedilla  gltnsmscedilla_sc  gltnsmtcedilla_sc)

// Ogonek composites:
cOgonekBase = (gltncapa  gltnsma  gltncape  gltnsme  gltncapu  gltnsmu  gltncapo  gltnsmo  gltncapomacron  gltnsmomacron);
cOgonekComposite = (gltncapaogonek g_aogonek gltncapeogonek g_eogonek g__uogonek
		gltnsmuogonek  gltncapoogonek  gltnsmoogonek  gltncapoogonekmacron  gltnsmoogonekmacron);

// Horn composites:
cHornBase = (gltncapo  gltnsmo  gltncapu  gltnsmu);
cHornComposite = (gltncapohorn  gltnsmohorn  gltncapuhorn  gltnsmuhorn);

// Modifier superscripts that require smaller diacritics:
cModSuper = (gmodsmh  gmodsmhhook  gmodsmj  gmodsmr  gmodsmtrndr  gmodsmtrndrhook  gmodsmcapinvr  gmodsmw  g02b8
		gmodglottalstop  gmodrevglottalstop  gmodsmgamma  gmodsml  gmodsms  gmodsmx  g02e4
		gmodcapa  gmodcapae  gmodcapb  g1d2f
		gmodcapd  gmodcape  gmodcapreve  gmodcapg  gmodcaph  gmodcapi  gmodcapj  g1d37
		gmodcapl  gmodcapm  gmodcapn  gmodcaprevn  gmodcapo  gmodcapou  gmodcapp  g1d3f
		gmodcapt  gmodcapu  gmodcapw  gltnsupsma  gltnsupsmturneda  gltnsupsmalpha  gmodsmtrndae  g1d47
		gltnsupsmd  gltnsupsme  gltnsupsmschwa  gltnsupsmopne  gmodsmtrndopne  gltnsupsmg  gmodsmtrndi  g1d4f
		gltnsupsmm  gltnsupsmeng  gltnsupsmo  gltnsupsmopno  gmodsmtophalfo  gmodsmbottomhalfo  gltnsupsmp  g1d57
		gltnsupsmu  gmodsmsdwysu  gltnsupsmturnedm  gltnsupsmv  gmodsmain  gmodsmbeta  gmodsmgrgamma  gmodsmdelta  gmodsmgrphi  gmodsmchi  g1d78
		gltnsupsmturnedalpha  gmodsmc  gltnsupsmccurl  gmodsmeth  g1d9f
		gltnsupsmf  gltnsupsmdotlessjstrk  gltnsupsmscriptg  gmodsmturnedh  gltnsupsmistrk  gmodsmiota  gltnsupsmcapi  g1da7
		gmodsmjcrossedtail  gltnsupsmlretrhook  gmodsmlpalhook  gmodsmcapl  gmodsmmhook  gltnsupsmturnedmlngleg  gltnsupsmnlfthook  g1daf
		gmodsmcapn  gltnsupsmbarredo  gmodsmphi  gmodsmshook  gltnsupsmesh  gmodsmtpalhook  gltnsupsmubar  g1db7
		gmodsmcapu  gmodsmvhook  gltnsupsmturnedv  gltnsupsmz  gmodsmzretrhook  gltnsupsmzcurl  gltnsupsmezh  gmodsmtheta  gltnsupsmi  g207f
		gltnsupsmi_dotless  gmodsmj_dotless  gltnsupsmistrk_dotless  gmodsmjcrossedtail_dotless);

// Modifier subscripts that require smaller diacritics:
cModSub = (gltnsubsmi  gltnsubsmr  gltnsubsmu  gltnsubsmv  ggrsubsmbeta  ggrsubsmgamma  ggrsubsmrho  ggrsubsmphi  g1d6a
		gltnsubsma  gltnsubsme  gltnsubsmo  gltnsubsmx  g2094
		gltnsubsmi_dotless);

// Vietnamese diacritic combinations

#if (FONT == GENTIUMfont)
c0302_noVN = (gcombcircum  gcombcircum_lp);
#else
c0302_noVN = (gcombcircum);
#endif

c0306_noVN = (gcombbreve);

cDiac_noVN = (g_acutecomb		g_gravecomb		gcombhookabv 	gcombtilde);
c_0302_DiacVN = (	g0302_acutecomb_vN		g0302_gravecomb_vN
					g0302_hookabovecomb_vN	gcombcircumtilde_vn);
c_0306_DiacVN = (	g0306_acutecomb_vN		g0306_gravecomb_vN
					g0306_hookabovecomb_vN	gcombbrevetilde_vn);

#if (FONT == GENTIUMfont)
cno_LP += (	g0302_acutecomb_vN		g0302_gravecomb_vN		g0302_tildecomb_vN		g0302_hookabovecomb_vN
			g0306_acutecomb_vN		g0306_gravecomb_vN		gcombbrevetilde_vn );
cLP += 	(	g0302_acutecomb_vNLP	g0302_gravecomb_vNLP	g0302_tildecomb_vNLP	g0302_hookabovecomb_vNLP
			g0306_acutecomb_vNLP	g0306_gravecomb_vNLP	gcombbrevetilde_vnlp );
#endif

// Precomposed base + first diac
c_baseCircum = (gltncapacircum, gltnsmacircum, gltncapecircum, gltnsmecircum,
				gltncapicircum, gltnsmicircum, gltncapocircum, gltnsmocircum,
				gltncapucircum, gltnsmucircum);
c_baseBreve  = (gltncapabreve, gltnsmabreve, gltncapebreve, gltnsmebreve,
				gltncapibreve, gltnsmibreve, gltncapobreve, gltnsmobreve, gltncapubreve, gltnsmubreve);
c_base_noDiac = (gltncapa, gltnsma, gltncape, gltnsme, gltncapi, gltnsmi, gltncapo, gltnsmo, gltncapu, gltnsmu);

// Vietnamese/literacy combinations

// a with stacked diacritics
c_aStack_noLit = (gltnsmacircumacute  gltnsmacircumgrave  gltnsmacircumhookabv  gltnsmacircumtilde  gltnsmabreveacute  gltnsmabrevegrave  gltnsmabrevetilde  gltnsmabrevehookabv); // eg, a+circum+acute
c_diacComb_vN = (gcombcircumacute_vn, gcombcircumgrave_vn,
			gcombcircumhook_vn, gcombcircumtilde_vn,
			gcombbreveacute_vn, gcombbrevegrave_vn,
			gcombbrevehook_vn, gcombbrevetilde_vn);


// These caron combinations are treated specially by European languages, which is the default:
cCaronEuro = (gltnsmdcaron, gltnsmlcaron, gltncaplcaron, gltnsmlcaron_sc, gltnsmtcaron);
cno_CaronEuro = (gltnsmd, gltnsml, gltncapl, gltnsml_sc, gltnsmt);

// These work for Doulos:
gltnsmdcaron {comp {base = box(0, bb.bottom-50m, (3*aw)/4, bb.top+50m);
                caron = box((3*aw)/4, bb.top - 450m, aw,bb.top+50m) }};

gltnsmlcaron {comp {base = box(0,bb.bottom-70m, (2*aw)/3, bb.top+50m);
                caron = box((5*aw)/8, bb.top - 450m, aw,bb.top+50m) }};

gltncaplcaron {comp {base = box(0,bb.bottom-50m, aw/2+70m, bb.top+50m);
                caron = box(bb.right-450m, bb.top-500m, bb.right-200m,bb.top+50m) }};

gltnsmlcaron_sc {comp {base = box(0,bb.bottom-50m, aw/2+70m, bb.top+50m);
                caron = box(bb.right-450m, bb.top-500m, bb.right-100m,bb.top+50m) }};

gltnsmtcaron {comp {base = box(0,bb.bottom-50m, bb.right-200m, bb.top-200m);
                caron = box(bb.right-300m, bb.top-450m, bb.right+50m, bb.top+50m) }};


// Uppercase-eng variations
// (The extra composite glyphs aren't really needed, they only happen to be in the font for AAT.)
c_eng_Descender = (gltncapeng, gltnsmeng_sc);                    // cno_BaselineHook = cno_Kom
c_eng_UCStyle = (gltncapeng_ucstyle, gltnsmeng_UCStyle_sc);  // (g__eng_u_c_style, g014A0301_uCStyle, g014A0300_uCStyle, g014A0302_uCStyle, g014A0303_uCStyle, g014A0323_uCStyle);
c_eng_BaselineHook = (gltncapeng_baselinehook, gltnsmeng_BaselineHook_sc);  // cBaselineHook;
c_eng_Kom = (gltncapeng_kom, gltnsmeng_Kom_sc);                  // cKom;

// V-hook variations
c_vhook_Curved = cno_StraightLft; // = cno_StraightLftHighHook
c_vhook_StraightLeft = cStraightLft;
c_vhook_HighHook = cStraightLftHighHook;

// Cyrillic shha (uses same tag as uppercase eng so we define these clases by hand):
cUCStyleCyrShha = (gcysmshha_ucstyle);
cno_UCStyleCyrShha = (gcysmshha);

// We need to add these explicitly because makegdl does not recognize the fact that
// 'g_dotlessi_s_italic' needs to be in the cDotless class.
// TODO: recheck when we switch over to the new version of make_gdl.
cDotless += (gltnsmdotlessi_sital); // g_dotlessi_tail_i;
cno_Dotless += (gltnsmi_sital);     // g_i_tail_i;

// Same with tail-i and j-serif.
#if (ANDIKAfamily)
cDotless    += (g_dotlessi_tail_i	gltnsmdotlessj_toplftserif);
cno_Dotless += (g_i_tail_i			gltnsmj_toplftserif);
#endif

// Same with the low-profile i and j.
#if (FONT == GENTIUMfont)
cDotless    += (g_i_dotless	gltnsmj_dotless);
cno_Dotless += (g_i_l_p		gltnsmj_lp);

// Also handle converting low-profile i/j to small caps.
cno_sc	+= (g_i_l_p		gltnsmj_lp);
c_sc	+= (g_i_sc		gltnsmj_sc);
#endif

#if (ANDIKAfamily)
// makegdl can't figure out that 'g_q_diag_tail_sc' needs to be in the cDiagTail class.
cno_DiagTail += (gltnsmq_sc);
cDiagTail    += (gltnsmq_diagtail_sc);
#endif

cno_BrInvBreve = (gcombinvbreve    gcombdblinvbreve);
cBrInvBreve_uU = (gcombinvbreve_uu g0361_uU);
cBrInvBreve_uL = (gcombinvbreve_ul g0361_uL);
cBrInvBreve_lL = (gcombinvbreve_ll g0361_lL);

cBridgeDiac = ( gcombdiaer_uu  gcombdiaer_ul  g0308_lL
				gcombinvbreve_uu  gcombinvbreve_ul  g0311_lL
				gcombdblinvbreve_uu  gcombdblinvbreve_ul  gcombdblinvbreve_ll);


// Narrow characters that need a narrow macron.
// Since this subsitution is done in the first pass, we only need to include encoded glyphs.

c_narrowMacron = (gltnsmi, gltnsml, gltnsmr, gltnsmt,
	gltnsmigrave, gltnsmiacute, gltnsmicircum, gltnsmidiaer, gltnsmitilde, gltnsmimacron, gltnsmibreve, gltnsmiogonek, gltnsmdotlessi,
	gltnsmlacute, gltnsmlcedilla, gltnsmlcaron, gltnsmlmiddledot, gltnsmlstrk,
	gltnsmracute, gltnsmrcedilla, gltnsmrcaron, gltnsmtcedilla, gltnsmtcaron, gltnsmtstrk, gltncapiota, gltnsmlbar, gltnsmthook, gltnsmicaron, gltnsmidblgrave,
	gltnsmiinvbreve, gltnsmrdblgrave, gltnsmrinvbreve, gltnsmtcommablw,
	gltnsmlcurl, gltnsmtcurl // l-curl, t-curl
	gltnsmrbar, gltnsmistrk, gltnsmiota, gltnsmlmiddletilde, gltnsmlbelt, gltnsmlretrhook, gltnsmrlngleg, gltnsmrfishhook, gltnsmturnedt, gltnsmtretrhook,
	gltnsmrmiddletilde, gltnsmrfishhookmiddletilde, gltnsmtmiddletilde, gltnsmiotastrk,
	gltnsmrpalhook,
	// g1e2d, g1e3d, g1e71, // i-lower-tilde, l-lower-circumflex, t-lower-circumflex
	gltnsmidiaeracute, gltnsmhdiaer, gltnsmldotblwmacron, gltnsmllineblw, gltnsmrdotabv, gltnsmrdotblw, gltnsmrdotblwmacron, gltnsmrlineblw, gltnsmtdotabv, gltnsmtdotblw, gltnsmtlineblw, gltnsmtdiaer, gltnsmihookabv,
	gltnsmidotblw, gltnsmdblbarredl, gltnsmtdiagstrk, gltnsmlhighbar,
	gltnsmlum, gltnsmrum, gltnsmtum // lum, rum, tum??
	gltnsminsularf, gltnsmltrnd, gltnsminsulars, gltnsmlretrhookbelt, gltnsmrdiagstrk);

c_narrowLowerDiac = (gcomblfthalfringblw, gcombuptackblw, gcombdwntackblw, gcombdotblw, gcombcommablw, gcombcedilla, gcombogonek, gcombvertlineblw, gcombbridgeblw, gcombdblvertlineblw);

/****
c_narrowMacron = (g_i,
	g_iacute, g_igrave, g_icircumflex, g_idieresis,
	g_i_s_ital, g0456, g2170, g_iacute_s_ital, g_igrave_s_ital, g0209,
	g0209_sItal, g_icircumflex_s_italic, g020b, g020b_sItal, g_ibreve, g_ibreve_s_ital,
	g01d0, g01d0_sItal, g_itilde, g_itilde_s_ital, g_imacron, g_imacron_s_ital,
	g_idieresis_s_ital, g0457, g1e2f, g1e2f_sItal, g_idotaccent, g_idotaccent_s_ital,
	g1ec9, g1ec9_sItal, g1e2d, g1e2d_sItal, g1ecb, g1ecb_sItal, g_iogonek,
	g_iogonek_retro_hook, g0268, g_i_dotless, g_dotlessi_s_ital,
	g_i_dotless_s_ital, g0456_dotless, g1d96_dotless, g0268_dotless, g1d09, g0269, g1d7c,

	g_l, g_l_s_ital, g217c, g2097, g2097_sItal, g02e1, g_lacute, g_lacute_s_ital, g_lcaron_caron, g1e3d,
	g1e3d_sItal, g1e3b, g1e3b_sItal, g1e37, g1e37_sItal, g1e39, g1e39_sItal, g_lcommaaccent,
	g_ldot, g_lcaron, g1d85, g1daa, g019a, ga749, g2c61, g026b, g_lslash, g026d, g1da9, g0234, g026c, ga78e, ga749_sItal,
	ga747, ga781,

	g_r, g_racute, g_rcaron, ga758, g1d514, g1d63, g1dca, g02b3, g036c, g_racute, g0211,
	g0213, g_rcaron, g1e59, g1e5f, g1e5b, g027d_lCStyle, g027c, g02b4, g027b, g02b5,

	g_t, g_tcaron_caron, g1e97, g1e6b, g1e71, g1e6f, g1e6d, g021b, g_tcaron, g0163, g01ab, g1db5,
	g_tbar, g1d75 );


#if (FONT == ANDIKAfont)

c_narrowMacron += (g0269_0301, g0269_0300, g0269_1dc7, g0269_0302, g0269_030c, g0269_0303, g0269_1dc6, g0269_0330,
	g_iogonek_tail_i_retro_hook, g0268_tailI, g0268_dotless_tailI, g_i_tail_i, g_dotlessi_tail_i,
	g_iacute_tail_i, g_igrave_tail_i, g0209_tailI, g_icircumflex_tail_i, g020b_tailI, g_ibreve_tail_i, g01d0_tailI,
	g_itilde_tail_i, g_imacron_tail_i, g1e2f_tailI, g_idieresis_tail_i, g1ec9_tailI, g1e2d_tailI, g1ecb_tailI,
	g_iogonek_tail_i,

	g_lcaron_caron_tail_l, g_l_tail_l, g_lacute_tail_l, g1e3d_tailL, g1e3b_tailL, g1e37_tailL, g1e39_tailL,
	g_lcommaaccent_tail_l, g_ldot_tail_l, g_lcaron_tail_l, g1d85_tailL, g1daa_tailL, g019a_tailL, g2c61_tailL,
	g026b_tailL, g_lslash_tail_l, g026c_tailL,

	g_tcaron_caron_no_tail_t, g0163_commaStyle_noTailT, g_t_no_tail_t, g1e97_noTailT, g1e6b_noTailT,
	g1e71_noTailT, g1e6f_noTailT, g1e6d_noTailT, g021b_noTailT, g_tcaron_no_tail_t, g0163_noTailT,
	g01ab_noTailT, g_tbar_no_tail_t, g1d75_noTailT, g2c66_noTailT);

#endif
****/

endtable; // glyph

// #include "pua.gdh"

#if (FONT == GENTIUMfont)
// Define the class of upper-case letters that need low-profile diacritics.
#include "takes_lowProfile.gdh"

table(glyph) {AttributeOverride = true}

cno_LP { lp_subclass = LP_BASEDIAC };
// The following glyphs have low-profile versions but do not have diacritics attached:
gltnsmi  { lp_subclass = LP_BASEONLY };
gltnsmj  { lp_subclass = LP_BASEONLY };
gltnsmligij { lp_subclass = LP_BASEONLY };
// The following glyphs are just diacritics:
cUDia { lp_subclass = LP_DIACONLY };


// The following are lower-case glyphs with precomposed upper diacritics that have no low-profile equivalents.
// Any diacritics that stack on top of them should be low-profile.
c_lowerWnonLPdiacs = ( gltnsmaringabv, gltnsmabreve, gltnsmebreve, gltnsmgbreve, gltnsmibreve, gltnsmobreve,
	gltnsmodblacute, gltnsmubreve, gltnsmudblacute, gltnsmadblgrave, gltnsmainvbreve, gltnsmedblgrave, gltnsmeinvbreve, gltnsmidblgrave,
	gltnsmiinvbreve, gltnsmodblgrave, gltnsmoinvbreve, gltnsmrdblgrave, gltnsmrinvbreve, gltnsmudblgrave, gltnsmuinvbreve, gltnsmecedillabreve, gltnsmwringabv, gltnsmyringabv, gltnsmarthalfring, gltnsmahookabv,
	gltnsmabrevedotblw, gltnsmehookabv, gltnsmihookabv, gltnsmohookabv, gltnsmohornhookabv, gltnsmuhookabv, gltnsmuhornhookabv, gltnsmyhookabv );

endtable;

#endif	// (FONT == GENTIUMfont)


//////////////////////////////////////////////////////////////////////////////////////
//
//	Features
//

#include "features.gdh"


//////////////////////////////////////////////////////////////////////////////////////
//
//	Rules
//

#if (FONT == GENTIUMfont)
// Combine any possible decomposed Greek into composed forms.
#include "greek_recompose.gdh"	// pass 1
#endif


table(substitution);

pass(1)  {MaxBackup = 15; MaxRuleLoop = 30}

// Decomposition/reordering
// Also Greek recomposition is done in pass 1 (in greek_recompose.gdh above).
// Also pitch processing (pitches.gdh).

/* --- removed feature ---
c_pua  >  c_noPua {pua = 1}  /  ^ _ ;
-------------------------- */

// Decompose possible vietnamese base + diac
c_baseCircum  _  >  c_base_noDiac:1  g0302:1  / ^ _ _;
c_baseBreve   _  >  c_base_noDiac:1  g0306:1  / ^ _ _;

// For the special bridging diacritic stuff, upper diacritics need to come first so they will attach
// to the first base (0311 and 0361 seem to be treated differently by NFD).
if (bridging_diac)
	cLDblDia  cUDblDia   >   @2  @1;
endif;


// Narrow macrons

if (!smallcaps)
gcombmacronblw  >  gcombmacronblw_short  /  c_narrowMacron  c_narrowLowerDiac? _ ;
endif;

endpass;  // sub - 1

#if (ANDIKAfamily)
if (smallcaps || (literacy == 0))
#else
if (smallcaps || literacy )
#endif

pass(2)

// Small-caps, literacy alternates

if (smallcaps)
	cno_sc  > c_sc;
endif;


// NB: Because 01E5 is affected by two features, barred_bowl and literacy,
// these features take special organization of their rules. Specifically,
// 01E5 should be displayed as:
//	if Literacy Alternates then LtnSmGBarredSngBowl (uni01E5.BarBowl.SngBowl)
//	else if Barred-Bowl Forms then LtnSmGBarredBowl (uni01E5.BarBowl)
//	else LtnSmGStrk (uni01E5)
// Note also that uni01E5 doesn't show up in any class.


// Note: literacy alternates take precedence over slant-italic feature (below).
// So we can ignore slant-italics here.
if (literacy == 1)
	cno_SngBowl  > cSngBowl;		// (includes uni01E5.BarBowl > uni01E5.BarBowl.SngBowl)
	// g01e5_barBowl_sngBowl is conceptually equal to g01e5_sngBowl (since the forms are the same).
	// Don't add this correspondence to the SngBowl forms to avoid confusing the reverse rules below;
	// just use a separate rule:
	gltnsmgstrk  >  g01e5_barBowl_sngBowl;

	cno_SngStory > cSngStory;

else
	cSngBowl  > cno_SngBowl;		// (includes uni01E5.BarBowl.SngBowl > uni01E5.BarBowl)
	cSngStory > cno_SngStory;
endif;


endpass;  // sub - 2

#if (ANDIKAfamily)
endif; // pass constraint: if (small_caps || (literacy == 0))
#else
endif; // pass constraint: if (small_caps || literacy)
#endif

pass(3)  {MaxBackup = 15; MaxRuleLoop = 30}

// Many features: slant italic, Chinantec tones, ogoneks, cedillas, horns, Vietnamese, bridging diacritics,
// engs, ramshorn, mongolian E, short breve, barred bowls, strokes, open-o serif, v-hook, y-hook,
// ezh-curl, t-hook, b-hook, h-stroke, r-tail, p-hook, Romanian, ezh, apostrophe, modifier-low-colon,
// carons, ou, empty-set, cyrillic-shha, serbian, serif-beta, digit variations, Andika variations...
// Also pitch processing (in pitches.gdh).

// TODO: the code below will have to be extended somewhat to correctly handle the case where
// the slant-italic glyphs are the default.

if (slant_italic == 1)
	// ff, fi, fl ligatures
	gltnsmf  cfLigC2  >  gltnsmf_sital cfLigC2_sItal   / _ _ cDia;  // don't create a ligature, a following diac stops ligature from forming
	gltnsmf  cfLigC2  >  _ cfLig_sItal:(1 2) {component {f1.ref = @1; f2.ref = @2}};

	gltnsmf  gltnsmf  cffLigC3  >  gltnsmf_sital  gltnsmf_sital  cffLigC3_sItal  / _ _ _ cDia;  // don't create a ligature
	gltnsmf  gltnsmf  cffLigC3  >  _ _  cffLig_sItal:(1 2 3) {component {f1.ref = @1; f2.ref = @2; f3.ref = @3}};

	cno_SItal  >  cSItal;		// f, i, l, v
	cno_2StorySItal  >  c2StorySItal;  // a, ae
else
	// ff, fi, fl ligatures
	gltnsmf  cfLigC2  >  @1 @2 / _ _ cDia; // do nothing, a following diac stops ligature from forming
	gltnsmf  cfLigC2  >  _ cfLig:(1 2) {component {f1.ref = @1; f2.ref = @2}}
		/  _ ^ _ ;	// back up to handle i-alternates

	gltnsmf  gltnsmf  cffLigC3  >  @1 @2 @3 / _ _ _ cDia;  // do nothing
	gltnsmf  gltnsmf  cffLigC3  >  _ _ cffLig:(1 2 3) {component {f1.ref = @1; f2.ref = @2; f3.ref = @3}}
		/  _  _ ^ _;	// back up to handle i-alternates

	cSItal        >  cno_SItal;
	c2StorySItal  >  cno_2StorySItal;
endif;


// Turn combining half-marks into one double-width combining mark
gfe20=d1  gfe21=d2  >  g0361:(d1 d2) _  /  ^ _  cTakesUDia  DIASTR5(cDia)  _ ;
gfe22=d1  gfe23=d2  >  g0360:(d1 d2) _  /  ^ _  cTakesUDia  DIASTR5(cDia)  _ ;

// For Chinantec, make the standard Unicode characters look like the special PUA characters.
if (chinantec_tone == 1)
	cno_ChinantecTn  >  cChinantecTn;
else
	cChinantecTn  >  cno_ChinantecTn;
endif;

// Handle ogoneks; backup needed to also handle literacy feature:
cOgonekBase  gcombogonek  >  cOgonekComposite$1:(b d)  _ {passKeySlot = true}  / ^ _=b  DIASTR4(cnODiaX)  _=d;

// Handle cedillas (including those that need to look like comma-accent by precomposing them);
// back-up needed to also handle rom feature:
cCedillaBase  gcombcedilla  >  cCedillaComposite$1:(b d)  _ {passKeySlot = true}  / ^ _=b  DIASTR4(cnHDiaX)  _=d;
// Handle horns:
cHornBase  gcombhorn  >  cHornComposite$1:(b d)  _ {passKeySlot = true}  /  _=b  DIASTR4(cnRDiaX)  _=d;

// Handle Vietnamese
/* jw comments
     2 stacked diacs go to side-by-side unless there is an intervening upper diac.
     pre-composed base + stacked diacs go to pre-composed base+side-by-side (cVN) */
if (viet == 1)
	// decompose the stacked form and replace the base 'a' with the literacy form,
	// the diacritics with the Vietnamese form
	_  c_aStack_noLit  >  g_a_sng_story:2  c_diacComb_vN / _ _ {literacy == 1};

	c0302_noVN  cDiac_noVN  >  c_0302_DiacVN$d:(b d)  _  / _=b DIASTR4(cnUDiaX) _=d;
	c0306_noVN  cDiac_noVN  >  c_0306_DiacVN$d:(b d)  _  / _=b DIASTR4(cnUDiaX) _=d;

	cno_VN > cVN; // ie, when literacy == false
else
	cVN > cno_VN;
endif;

table(glyph)
cls_l_lower = (gltnsml, gltnsml_sc);	// include small caps
cls_o_lower = (gltnsmo, gltnsmo_sc);
cls_u_lower = (gltnsmu, gltnsmu_sc);
endtable;

if (bridging_diac)
	// LL with bridging diaeresis (U+035F is possible intervening bridging underbar)
	gcombdiaer  >  gcombdiaer_uu  /  gltncapl  gcombdblmacronblw?  _  gcombdblmacronblw?  g__l;
	gcombdiaer  >  gcombdiaer_ul  /  gltncapl  gcombdblmacronblw?  _  gcombdblmacronblw?  cls_l_lower;
	gcombdiaer  >  gcombdiaer_ll  /  cls_l_lower  gcombdblmacronblw?  _  gcombdblmacronblw?  cls_l_lower;

	// OU with bridging inverted breve (0311 / 0361)
	cno_BrInvBreve  >  cBrInvBreve_uU  /  gltncapo  gcombdblmacronblw?  _  gcombdblmacronblw?  g__u;
	cno_BrInvBreve  >  cBrInvBreve_uL  /  gltncapo  gcombdblmacronblw?  _  gcombdblmacronblw?  cls_u_lower;
	cno_BrInvBreve  >  cBrInvBreve_lL  /  cls_o_lower  gcombdblmacronblw?  _  gcombdblmacronblw?  cls_u_lower;
endif;

#if DEBUG

if (debug == 1)
	gqstnmrk > g_one		/ DeBuG gspace g_e gltnsmn g_g geqsgn _ {eng == 0};
	gqstnmrk > g_two		/ DeBuG gspace g_e gltnsmn g_g geqsgn _ {eng == 1};
	gqstnmrk > g_three	/ DeBuG gspace g_e gltnsmn g_g geqsgn _ {eng == 2};
endif;

#endif  // DEBUG

/*
	NOTES:

	The rules are designed so that they work correctly no matter how the
	default value for a feature is set. While this means the rules don't
	demand that the cmap and feature table agree on the default glyph,
	the font will be more usable in non-GDL apps if they do agree.
	(One exception remaining is vietnamese processing -- so don't
	try to build a font with vietnamese on by default).

	If a glyph name extension (which is what drives the class names) is used
	within more than one feature (e.g., .LrgBowl is used in the Rams horn alternate
	and the Small ezh-curl alternate), then we cannot use the automatically generated
	class names (e.g., cLrgBowl and cno_LrgBowl), but rather must explicitly
	handle each glyph -- sigh.
*/

if (eng == descender)
	// for fonts with default = base, capital, or short:
	c_eng_BaselineHook  >  c_eng_Descender;
	c_eng_UCStyle       >  c_eng_Descender;
	c_eng_Kom           >  c_eng_Descender;
endif;
if (eng == base)
	// for fonts with default = descender, capital, or short:
	c_eng_Descender   >  c_eng_BaselineHook;
	c_eng_UCStyle     >  c_eng_BaselineHook;
	c_eng_Kom         >  c_eng_BaselineHook;
endif;
if (eng == capital)
	// for fonts with default = descender, base, or short:
	c_eng_Descender    >  c_eng_UCStyle;
	c_eng_BaselineHook >  c_eng_UCStyle;
	c_eng_Kom          >  c_eng_UCStyle;
endif;
if (eng == short)
	// for fonts with default = descender, capital, or base:
	c_eng_Descender    >  c_eng_Kom;
	c_eng_BaselineHook >  c_eng_Kom;
	c_eng_UCStyle      >  c_eng_Kom;
endif;

if (ramshorn == small)
	// for fonts with default = large or gamma
	(gltnsmramshorn_lrgbowl  gltnsmramshorn_gammastyle) > g0264;
endif;
if (ramshorn == large)
	// for fonts with default = small or gamma
	(gltnsmramshorn 	gltnsmramshorn_gammastyle)	> g0264_lrgBowl;
endif;
if (ramshorn == gamma)
	// for fonts with default = small or large
	(gltnsmramshorn  gltnsmramshorn_lrgbowl)		> g0264_gammaStyle;
endif

// supernum feature dealt with in pitches.gdh

if (mongol_e == 1)
	cno_MongolStyle > cMongolStyle;
else
	cMongolStyle >cno_MongolStyle;
endif;

#if 1 // FONT != DOULOSfont
/**** obsolete feature
if (cyr_curs_ital == 1)
	cno_Cursive  >  cCursive;
else
	cCursive  >  cno_Cursive;
endif;
****/
#endif // !DOULOSfont

if (short_breve == 1)
	cno_CyShortMrkAlt > cCyShortMrkAlt;
else
	cCyShortMrkAlt > cno_CyShortMrkAlt;
endif;

if (invis == 1)
	cno_ShowInv > cShowInv;
endif;


// --- literacy and slant_italic features moved from here. ---


// The barred_bowl rule must happen *after* the literacy rule
if (barred_bowl == 1)                   //  does contain g01E5, no such naming as uni01e5 or
                                        // uni anything. That is the Postscript Name from xml file.  jw 8/27/04
	cno_BarBowl  >  cBarBowl;	// (does NOT include uni01E5 > uni01E5.BarBowl)
//	g01e5  >  g01e5_barBowl;		        yes it does jw.  commented 8/31
//					see: cno_BarBowl = (g0180, g_dcroat, g01e5);
else
	cBarBowl  >  cno_BarBowl;	// (does NOT include uni01E5.BarBowl > uni01E5)
//	g01e5_barBowl  >  g01e5;			yes it does jw
endif;

if (ltnjstroke == doubleSerif)
	cno_DblSerif  >  cDblSerif;
else
	cDblSerif  >  cno_DblSerif;
endif;

if (open_o == topSerif)
	cno_TopSerif  >  cTopSerif;
else
	cTopSerif  >  cno_TopSerif;
endif;

if (v_hook == curved)
	c_vhook_StraightLeft >  c_vhook_Curved;
	c_vhook_HighHook     >  c_vhook_Curved;
endif;
if (v_hook == straightLeft)
	c_vhook_Curved    >  c_vhook_StraightLeft;
	c_vhook_HighHook  >  c_vhook_StraightLeft;
endif;
if (v_hook == highHook)
	c_vhook_Curved       >  c_vhook_HighHook;
	c_vhook_StraightLeft >  c_vhook_HighHook;
endif;

if (y_hook == 1)
	cno_RtHookYhook  >  cRtHookYhook;
else
	cRtHookYhook  >  cno_RtHookYhook;
endif;

if (n_hook == 1)
	cno_LCStyleNhook  >  cLCStyleNhook;
else
	cLCStyleNhook  >  cno_LCStyleNhook;
endif;

if (ezh_curl == 1)
	gltnsmezhcurl  >  g0293_lrgBowl;
else
	gltnsmezhcurl_lrgbowl  >  g0293;
endif;

if (t_hook == 1)
	cno_RtHookThook  >  cRtHookThook;
else
	cRtHookThook  >  cno_RtHookThook;
endif;

if (b_hook == 1)
	cno_TopBarB  >  cTopBarB;
else
	cTopBarB  >  cno_TopBarB;
endif;

if (d_hook == 1)
	cno_TopBarD  >  cTopBarD;
else
	cTopBarD  >  cno_TopBarD;
endif;

if (h_stroke == 1)
	cno_VertStrk  >  cVertStrk;
	////cno_BarStem  >  cBarStem;
else
	cVertStrk  >  cno_VertStrk;
	////cBarStem  >  cno_BarStem;
endif;

if (r_tail == 1)
	cno_LCStyleRtail  >  cLCStyleRtail;
else
	cLCStyleRtail  >  cno_LCStyleRtail;
endif;

if (p_hook == 1)
	cno_BowlHook  >  cBowlHook;
else
	cBowlHook  >  cno_BowlHook;
endif;

/* --- removed feature ---
if (rom == 1)
	cno_CommaStyle  >  cCommaStyle;
else
	cCommaStyle  >  cno_CommaStyle;
endif;
-------------------------- */

if (ezh == 1)
	cno_RevSigmaStyle  >  cRevSigmaStyle;
else
	cRevSigmaStyle  >  cno_RevSigmaStyle;
endif;

// ogonek processing must be in pass 2

if (apostrophe == 1)
	cno_Lrg  >  cLrg;
else
	cLrg  >  cno_Lrg;
endif;

if (modlowcolon == wide)
  cno_Wide >  cWide;	// a789, was gf1e9
  //gf1e9  >  gf1e9_wide;
else
  cWide  >  cno_Wide;
  //gf1e9_wide  >  gf1e9;
endif;

if (caron == 0)
	// European caron combinations (feature OFF)
	//if (select_diac)
	//	cno_CaronEuro  g030c  >  _  cCaronEuro$1:(1 2) {comp {base.ref = @1; caron.ref = @2}; passKeySlot=1};
	//else
		cno_CaronEuro  gcombcaron  >  _  cCaronEuro$1:(1 2) {passKeySlot=1};
	//endif;
endif;
if (caron == 1)
	// Non-European caron but NFC: decompose and use standard caron
	cCaronEuro  _  >  cno_CaronEuro:1  g030c:1;
endif;

if (ou == 1)
	cno_OpenTop  >  cOpenTop;
else
	cOpenTop  >  cno_OpenTop;
endif;

if (emptyset == 1)
	cno_SlashZero  >  cSlashZero;
else
	cSlashZero  >  cno_SlashZero;
endif;

/* --- Obsolete feature ---
if (ltnglottalstop == capHeight)
  g0294_lC  >  g0294;
else
  g0294  >  g0294_lC;
endif;
--------------------------- */

if (cyrillic_shha == 1)
	cno_UCStyleCyrShha  >  cUCStyleCyrShha;
else
	cUCStyleCyrShha  >  cno_UCStyleCyrShha;
endif;

if (serbian == 1)
	cno_Serb  >  cSerb;
else
	cSerb  >  cno_Serb;
endif;

#if (FONT == GENTIUMfont)

if (serif_beta == 1)
	cno_Serif  >  cSerif;
else
	cSerif  >  cno_Serif;
endif;

if (greek_circ == 1)
	cno_Por  >  cPor;
else
	cPor  >  cno_Por;
endif;

#endif // GENTIUMfont


#if (ANDIKAfamily)

if (zero == 1)
	cno_Slash  >  cSlash;
else
	cSlash  >  cno_Slash;
endif;

if (one == 1)
	cno_NoBase  >  cNoBase;
else
	cNoBase  >  cno_NoBase;
endif;

if (four == 1)
	cno_Open  >  cOpen;
else
	cOpen  >  cno_Open;
endif;

if (six_nine == 1)
	cno_Diag  > cDiag;
else
	cDiag  >  cno_Diag;
endif;

if (seven == 1)
	cno_Bar  >  cBar;
else
	cBar  >  cno_Bar;
endif;

if (i_hook == 1)
	cno_TailI  >  cTailI;
else
	cTailI  >  cno_TailI;
endif;

if (j_serif == 1)
	cno_TopLftSerif  >  cTopLftSerif;
else
	cTopLftSerif  >  cno_TopLftSerif;
endif;

// No-Tail-T, Tail-L - see below

if (q_diagtail == 1)
	cno_DiagTail  >  cDiagTail;
else
	cDiagTail  >  cno_DiagTail;
endif;

if (q_point == 1)
	cno_Point  >  cPoint;
else
	cPoint  >  cno_Point;
endif;


if (y_tail == 1)
	cno_NoTailY  > cNoTailY;
else
	cNoTailY  >  cno_NoTailY;
endif;

#endif	// ANDIKAfamily

endpass;  // sub - 3


pass(4)  {MaxBackup = 15; MaxRuleLoop = 30}	// substitution

// Low-profile diacritics, more Andika features, dotless i + diac, ogonek, superscript/subscript diac,...


#if (FONT == GENTIUMfont)

// Low-profile diacritics--do this after processing Vietnamese.

// All stacking diacritics should be low-profile.
// In each of these rules we back up to handle dotless stuff.

// Mark the upper diacritic as needing low-profile because it is in a stack:
cno_LP  cUDia  >  cLP  @U {needs_lp = 1}  / ^ _ {lp_subclass == LP_DIACONLY}  DIASTR4(cnUDiaX)  _=U;
cno_LP  >  cLP  /  ^ _ {needs_lp == 1};  // needs LP because it follows an LP-diac from rule above
cno_LP  >  cLP  /  cUDia ^ _ {lp_subclass == LP_DIACONLY};
cno_LP  >  cLP  / c_lowerWnonLPdiacs ^ _;	// eg, NFC e-breve+circumflex, w-ring+acute

// Make sure to use low-profile diacritics on any decomposed uppercase.
cno_LP  >  cLP  /  cTakesLPDiac  DIASTR4(cnUDiaX) ^ _ {lp_subclass == LP_DIACONLY} ;

// Don't try to do low-profile stuff with small-caps.
if (low_profile_diac && !smallcaps)
	cno_LP  >  cLP  / ^ _;	// back up to handle dotless stuff
endif;

#endif // GENTIUMfont


#if (ANDIKAfamily)

// Andika features that interact with other features

if (t_tail == 1)
	cno_NoTailT  >  cNoTailT;
else
	cNoTailT  >  cno_NoTailT;
endif;

if (l_hook == 1)
	cno_TailL  >  cTailL;
else
	cTailL  >  cno_TailL;
endif;

#endif // ANDIKAfamily


// Convert i to dotless i when followed by upper diacritic.

// decomposed sequences:
cno_Dotless  cUDia=D  >  cDotless  @D {passKeySlot=1}  /  _  ^  DIASTR4(cnUDiaX)  _=D;
// precomposed chars with i are done by decomposition:
cSpecialDotted  _  cUDia=D  >  gltnsmi_dotless  cSpecialDottedDia$1:1  @D {passKeySlot=1}
	/  _  _  ^  DIASTR4(cnUDiaX)  _=D;

// Now that ogonek has been composed with its vowels, do retrohook style if wanted:

if (ogonek == americanist)
	cno_RetroHook > cRetroHook;
else
	cRetroHook > cno_RetroHook;
endif;

//	g__aogonek	> g__a g0328_retroHook:1;
//	g_aogonek	> g_a  g0328_retroHook:1;
//	g__eogonek	> g__e g0328_retroHook:1;
//	g_eogonek	> g_e  g0328_retroHook:1;
//	g__iogonek	> g__i g0328_retroHook:1;
//	g_iogonek_dotless > g_i_dotless g0328_retroHook:1;
//	g_iogonek	> g_i  g0328_retroHook:1;
//	g__uogonek	> g__u g0328_retroHook:1;
//	g_uogonek	> g_u  g0328_retroHook:1;
//	g01ea		> g__o g0328_retroHook:1;
//	g01eb		> g_o  g0328_retroHook:1;
//	g01ec		> g__omacron g0328_retroHook:1;
//	g01ed		> g_omacron  g0328_retroHook:1;
//	g_ogonek	> g_ogonek_retro_hook:1;
//	g0328		> g0328_retroHook:1;
//endif;


// Handle superscript/subscript diacritics; currently the only one of interest is a diaeresis:
cno_Sup  >  cSup  /  (cModSuper cModSub)  _;


/* --- removed feature ---
// Deprecated PUA

if (dep_pua == unicode51)
	cno_Dep51  >  cDep51  /  _ {pua==1};
endif;
if (dep_pua == unicode50)
	cno_Dep50  >  cDep50  /  _ {pua==1};
endif;
if (dep_pua == unicode41)
	cno_Dep41  >  cDep41  /  _ {pua==1};
endif;
if (dep_pua == unicode40)
	cno_Dep40  >  cDep40  /  _ {pua==1};
endif;
-------------------------- */


endpass;  // sub - 4


endtable; // substitution


#include "pitches.gdh"


table(positioning) {MUnits = 1000};

// Handle attachments

pass(1)

#define pos_rule(t, x, a, w, n) t x {attach {to = @1; at = a; with = w}; attached = 1} / ^ _ DIASTR4(n) _{attached == 0}
#define pos_ruleSD(t, x, a, w, n) t x {attach {to = @1; at = a; with = w}; insert = 1; attached = 1} / ^ _ DIASTR4(n) _{attached == 0}


//if (select_diac)
//	pos_ruleSD(cTakesHDia, cHDia, HS, HM, cnHDiaX);
//	pos_ruleSD(cTakesLDia, cLDia, LS, LM, cnLDiaX);
//	pos_ruleSD(cTakesODia, cODia, OS, OM, cnODiaX);
//	pos_ruleSD(cTakesRDia, cRDia, RS, RM, cnRDiaX);
//	pos_ruleSD(cTakesUDia, cUDia, US, UM, cnUDiaX);
//else
	pos_rule(cTakesHDia, cHDia, HS, HM, cnHDiaX);
	pos_rule(cTakesLDia, cLDia, LS, LM, cnLDiaX);
	pos_rule(cTakesODia, cODia, OS, OM, cnODiaX);
	pos_rule(cTakesRDia, cRDia, RS, RM, cnRDiaX);
	pos_rule(cTakesUDia, cUDia, US, UM, cnUDiaX);
//endif;


// Bridge diacritics handled by attachment need to have zero advance width,
// otherwise they push the second character out and away. (This wouldn't work if above
// we didn't reprocess attached diacritics using the ^ mechanism.)
cBridgeDiac {advance.x = 0};

endpass; // pos - 1


// Handle double-diacritics

pass(2)	// positioning

	// Double-diacritics above: the ".1" gives the bounding box of the attached cluster of
	// base + diacritics.

	// Something on both sides:
	cUDblDia {shift.y = max(@B.boundingbox.top.1, @A.boundingbox.top.1) - @D.boundingbox.bottom + 100m ;
			shift.x = (@A.boundingbox.width.1 - @B.boundingbox.width.1)/2; insert = 1}
			/ cTakesUDia=B  DIASTR3(cDia)  cLDblDia?  _=D  DIASTR3(cDia)  cTakesUDia=A;
	// Beginning of line:
	cUDblDia {shift.y = @B.boundingbox.top.1 - @D.boundingbox.bottom + 100m ; insert = 1}
			/ cTakesUDia=B  DIASTR5(cDia)  cLDblDia?  _=D;
	// End of line:
	cUDblDia {shift.y = @A.boundingbox.top.1 - @D.boundingbox.bottom + 100m ; insert = 1}
			/ DIASTR5(cDia)  cLDblDia?  _=D  cTakesUDia=A;

endpass; // pos - 2


pass(3)

	// Double-diacritics below:

	// Special case for two bridging diacritics:
	gcombdblmacronblw {shift.y = min(@B.boundingbox.bottom.1, @A.boundingbox.bottom.1) - @D.boundingbox.top -100m ;
		  shift.x = (@A.boundingbox.width - @B.boundingbox.width)/2; insert = 1}
		  / cTakesLDia=B  DIASTR3(cDia)  cUDblDia?  _=D  cUDblDia?  DIASTR3(cDia)  cTakesLDia=A;
	cLDblDia {shift.y = min(@B.boundingbox.bottom.1, @A.boundingbox.bottom.1) - @D.boundingbox.top -100m ;
		  shift.x = (@A.boundingbox.width.1 - @B.boundingbox.width.1)/2; insert = 1}
		  / cTakesLDia=B  DIASTR3(cDia)  cUDblDia?  _=D  cUDblDia?  DIASTR3(cDia)  cTakesLDia=A;
	cLDblDia {shift.y = @B.boundingbox.bottom.1 - @D.boundingbox.top -100m ; insert = 1}
			/ cTakesLDia=B  DIASTR5(cDia)  cUDblDia?  _=D ;
	cLDblDia {shift.y = @A.boundingbox.bottom.1 - @D.boundingbox.top -100m ; insert = 1}
			/ DIASTR5(cDia)  cUDblDia?  _=D  cTakesLDia=A ;


endpass; // pos - 3

////#include "kern.gdh"

endtable; // positioning
